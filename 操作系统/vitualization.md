**1、进程？**

- 程序是静态的、进程是动态运行的程序、进程==状态机
- 进程管理：状态机的创建、管理、销毁

**2、创建进程：fork()**

- 理解fork()函数的返回值

  - ```c++
    int a = fork();
    int b = fork();
    int c = fork();
    cout<<"a"<<a<<"b"<<b<<"c"<<c<<endl;
    ```

  - ```c++
    for(int i=0;i<2;i++){
    	printf("hello\n");
    }
    ```

  - ```c++
    :(){:|:&};://fork bomb
    ```

- 多线程执行fork时会发生什么？

  - fork的创始人没有考虑线程

**3、状态机管理：替换状态机**

- 将当前运行的状态机重置位另一个程序的初始状态

- ```c++
  int execve(const char *filename,char *const argv,char *const envp)
  ```

  - 执行名为filename的程序
  - 允许对新状态机设置参数argv(v)和环境变量envp(e)

**4、销毁状态机：_exit()**

- 销毁当前状态机，并允许有一个返回值

- 子进程会通知父进程

- 多版本的退出

  ```c++
  exit(0);//是_exit(0)的一种封装
  _exit(0);//直接退出，结束进程
  syscall(SYS_exit,0);//结束线程，但不结束进程里的其他线程
  ```

**5、进程需要保障什么？**

- 怎么保证程序不能执行受到操作系统限制的指令
  - 用户模式与内核模式的切换
- 如何实现进程的切换	
  - 上下文切换，进程切换时动作
  - 内核栈，进程对应的数据结构

**6、文件描述符**

- 文件描述符的理解

  ```c++
  int main(){
  	int fd = dup(1);//找到一个指针拷贝原来的位置
  	freopen("output.txt","w",stdout);//标准输出重定向到txt
  	printf("hello\n");
  	fclose(stdout);//关闭标准输出
  	freopen("/dev/null","w",stdout);//指定一个合法的文件
  	dup2(fd,1);//将左边复制给右边
  	close(fd);//关闭原来的
  	printf("world\n");
  }
  ```

- fork()时进程的所有文件描述符都会被子进程继承，父子进程同时写文件，会不会被覆盖，后面会介绍

  ```c++
  fork-printf.c
  ```

- fork应用

  - 跳过初始化
    - Java Virtual Machine 初始化设计大量的类加载，一次加载，全员使用
  - 实现”备份“的容错
    - 定期给程序做备份性质的快照，fork之后在原地停留，主进程crash之后，启动快照重新执行
  - A fork() in the road
    - fork线程不安全
    - fork比较慢

**7、地址空间的抽象**

- 为什么会需要地址空间的抽象？
  - 早期计算机价格高，需要计算机能执行更多的程序、出现了分时系统。时分共享首先是让进程单独占用全部内存运行一小段时间，停止之后将它的状态信息保存在磁盘上，加载其他进程的状态信息，再运行一段时间，但是内存增加之后，保存全部的内存信息保存到磁盘上就太慢了，解决办法就是将分区存储进程的所有信息。但多个程序保存在同一个磁盘区间中，出现了新的问题，不允许其他进程对当前进程所拥有的内存区间进行修改。
- 地址空间
  - 操作系统提供一个易用(easy to use)的物理内存抽象，这个抽象被叫做地址空间(address space)，是运行的程序看到的系统中的内存。

