# 大纲

##### 1232 缀点成线

- double类型数据比较
- 向量的相关性判断是够共线

##### 721 账户合并

- 并查集
- vector的insert用法，向量中插入vector

##### 1584 连接所有点的最小费用

- prim算法
- lambada表达式
- Kruskal算法
- 依据对象某一属性对对象进行排序,sort

##### 628 三个数最大乘积

- 分情况想像一下即可...
- 使用反向迭代器进行排序

##### 1489 找到最小生成树里的关键边和伪关键边

- 并查集按秩优化
- clsukal算法
- 关键边的分析

##### 17 九键字母

##### 18 二维数组查找单词

##### 46 全排列

##### 50 全排列2

##### 78 子集

##### 90 子集2

##### 216 三个数的和

##### 52 N皇后

##### 37 数独

## 树

##### 98 验证二叉搜索树

- 二叉搜索树的定义
- 解法一：二叉搜索树的中序遍历是升序
- 解法二：任一节点能唯一确定一个范围，自顶向下的方法
- 递归的写法

##### 94 二叉树的中序遍历

- 迭代的写法
- 递归的写法

##### 101对称二叉树
- 验证二叉树和二叉树中序遍历的升级版本
- 迭代写法
- 递归写法

##### 105从前序遍历以及中序遍历构造二叉树

- 递归
- **~~迭代~~**

##### 102 二叉树的层次遍历

- 利用队列求二叉树的层次遍历
- C++队列的api

##### 236 二叉树的最近公共祖先

- 深入理解递归的题目
- [优秀题解](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/solution/236-er-cha-shu-de-zui-jin-gong-gong-zu-xian-hou-xu/)

##### 124 二叉树中的最大路径和

- 权重为负数
- 104题的升级版本

##### 687 最长同值路径

- 综合题
- [优秀题解](https://leetcode-cn.com/problems/longest-univalue-path/solution/687-by-ikaruga/)

##### 543 二叉树的直径

- 递归
- [优秀题解](https://leetcode-cn.com/problems/diameter-of-binary-tree/solution/shi-pin-jie-shi-di-gui-dai-ma-de-yun-xing-guo-chen/)

##### 104 二叉树的最大深度

- 迭代
- 简单题

##### 173 二叉搜索树迭代器

- 中序遍历的迭代写法
- 理解题目的意思

##### 297

## 滑动窗口、双指针、单调队列、单调栈

##### 167 两数之和

- 暴力解法
- 双指针

##### 88 合并两个有序数组

- 三指针
- 从后往前

##### 26 删除排序数组的重复项

- 最后一个元素问题
- 指针的思想，以及指针表示的实际意义

##### 76 最小覆盖子串

- 滑动窗口
- 哈希表的使用
- 困难写字母 每个节点都必须用长度为26的数组进行节点保存1 月前回复￼
  ￼

##### 32 最长有效括号

- 括号的性质

##### 42 最小栈

- 辅助栈
- 应该不需要优化

##### 155 接雨水

- 单调栈解决一类问题
  - 快速查找每个数左侧第一个比他他的水
- 单调队列
  - 查找滑动窗口的最值

##### 84 柱状图中的最大矩形

- 单调栈模版

##### 918 环形子数组的最大和

- 

##### 239 滑动窗口最大值

- 单调队列的暴力解法
- 

##### 496 下一个更大的元素(1)

##### 503 下一个更大元素(2)

##### 739 每日温度

##### 901 股票价格跨度

## 贪心

##### 860 柠檬水找零

- 模拟+贪心
- 贪心算法(某种意义上的局部最优解)

##### 392 判断子序列

- 双指针问题，单调性
- 大量需要验证的子序列的处理办法

##### 455 分发饼干

- 暴力解法
- 排序优化

##### 55 跳跃游戏

- 贪心的思想
- for循环的使用

##### 45跳跃游戏(2)

- 

##### 376

##### 406

##### 452

##### 402

##### 134

## 基础算法

##### 快速排序

- 快速排序是不稳定的

- 算法思想
  - 分冶算法
- 算法步骤
  - 确定分界点，在排序的数组中随机选择一个点作为分界点
  - 调整区间，使得第一个区间的数均小于等于x，右边的数均大于等于x【难点】
  - 递归处理左右两端
- 算法技巧
  - 双指针交换数值，完成调整区间这一步

##### 归并排序

- 归并算法是稳定的
- 复杂度 nlogn

- 算法主题思想和快速排序一样
- 确定分界点这一处选定的是中间的分界点
- 将两个有序的数组合并，合二为一【难点】
  - 算法技巧
    - 双指针算法

##### 整数二分

- 寻找边界问题，左边界满足某种性质，右边界不满足某种性质
- 只要我们能找到这个性质，我们就可以使用二分找到这个性质的分界点
- 有单调性可以用二分，没有单调性也有二分
- 算法步骤
  - 定中点
  - 检查中点，check函数
- 二种模版
  - 区间被划分为```[l,mid-1][mid,r]```时使用
  - 区间被换分为```[l,mid][mid+1,r]```时使用
- 先写模版，在考虑是否需要加1
- 一定要有解，但可以根据边界判断题目对否有解

##### 实数二分对大的数进行加减乘除

- 考虑浮点数精度问题，一般是保留位数加上2
- 直接暴力循环100次，保证精度

##### 高精度

- 大整数的存储
  - 大数使用`string`读进来，然后赋值到数组当中
  - C++中大整数的存储(123456789),使用数组进行存储，低位存个位数
  - 如果需要进位，高位加一，在数组末端加上一个数比较容易
- 高精度加减法
  - 使用进位标志即可
  - 模拟
- 高精度乘法
  - 一个大数乘以一个小一点的数
  - 高精度乘法把小数当做一个整体，仍然使用进位标志来求
  - `LeetCode 43`
- 高精度除法
  - 一个高精度数除以一个低精度数
  - 多余操作，记得`reverse`
  - 去除前导零

##### 前缀和、差分

- 前缀和
  - 一维前缀和
    - `sum`数量多开一个,定义`S[0]=0`
    - 快速求出一段数的和 `S[Right]-S[left-1]`
  - 二维前缀和
    - 求指定区域的所有元素的和
    - 例子：子矩阵的和
    - 公式求前缀和、求计算
- 差分
  - 一维差分
    - 由前缀和反求原来的数组
    - 应用：对一个区域内的数值全部加上一个同一个值
      - 将原数组(记为a)理解为某一数组(记为b)的前缀和
      - 对a中[left,right]范围内的数值全部加上c则可以表示为```b[left]+c,b[right+1]-c```
      - 然后再由差分数组生成前缀和数组，也即是我们要求解的变换后的a
    - 技巧
      - 初始化一个数组，采用插入的方法插入a[i],即得到差分数组
      - 对差分数组进行m次插入操作即完成
  - 二维差分
    - 对原来的矩阵中某一个区域内的每个数相加一个数

##### 双指针算法

- 优化问题的一种方法

- 从朴素解法开始、发掘题目的性质

  ```C++
  int res=0;
  for(int i=0,j=0;i<n;i++){
      while(j<=i && check(j,i)){
          j++;
      }
      res =max(res,i-j+1);
  }
  ```

##### 位运算

- `lowbit`
  - `lowbit(x) = x & （-x）= x&(~x+1)`表示二进制表达式中最低位的1所对应的值
  - `lowbit(6) = 2`
  - 整数的负数的二进制表示为原数的二进制表示取反加1
- 求一个数的二进制数里面有多少个
  - 将原数每次减去lowbit(x)
- 原码、反码、补码

##### 整数离散化

- 把无限空间中有限个体映射到有限的空间中去

- 两个问题

  - 有重复的数字，需要去重

    - unique去重，然后ereaser

    - ```C++
      sort(alls.begin(),alls.end());  //排序
      alls.erase(unique(alls.begin(),alls.end()),alls.begin()); //去重
      ```

  - 快速算出离散化的值，二分 

- 例子

  - 无限长的数轴，只有几个数是有值的，计算一个大区间内的值
  - 将有值的横坐标映射到1~n，使用二分来映射，二分映射之前需要去重

##### 区间合并

- 很多个有交集的区间合并，返回合并后区间的个数
- 算法步骤：贪心思想
  - 按照区间的左端点进行排序
  - 维护一个区间，扫描整个区间

## 基础数据结构

##### 链表和邻接表

- 数组模拟单链表

  - 单链表用途为实现邻接表，邻接表一般用来存储树和图

- 使用双数组加上头节点来模拟链表

  - 头结点表示下标

  - 一个e数组用来存储节点i的值，ne数组存储节点i的下一个位置

  - idx存储当前用到哪个点

  - ```C++
    //初始化
    void init(){
        head = -1;
        idx = 0;
    }
    //添加到头结点
    void add_to_head(int x){
        /*第一步，赋值并指向之前头结点指向的位置*/
        e[idx] = x;  //将x存下来
        ne[idx] = head; //指向下一位
        /*第二步，更新头结点指向的位置*/
        head = idx; //头节点指向idx
        idx++;
    }
    //将x插到下标为k的点的后面
    void add(int k,int x){
        e[idx] = x;
        ne[idx] = ne[k];
        ne[k] = idx;
        idx++;
    }
    //将下标为k的后一个点删除掉
    void remove(int k){
        ne[k] = ne[ne[k]];
    }
    ```

- 双链表用来优化某些问题

  - ```C++
    //初始化
    void init(){
    //0表示左端点、1表示右端点
    	r[0] = 1,
        l[1] = 0;
        idx = 2;
    }
    //在下标为k的右边插入一个新的点，添加操作，4条操作
    void add(int k,int x){
        e[idx] = x;
        //先插入新增的两条
        r[index] = r[k];
        l[index] = k;
        //对原来不对两条边的进行更改，注意下面两条的顺序
        l[r[k]] = idx; //需要先将原来k后面我的一个点的左指针改掉，再来改右边的
        r[k] = idx;
        //l[r[k]] = idx;
    }
    //删除第k个点
    void remove(int k){
        r[l[k]] = r[k];
        l[r[k]] = l[k];
    }
    ```

- 邻接表
  
  - 单链表的组合

##### 单调队列单调栈

- 栈

  - ```C++
    //tt表示栈顶元素
    int stk[N],tt=0;
    //插入
    stk[++tt] = x;
    //删除
    tt--
    //判断是否为空
    return tt>0?true:false;
    //取出栈顶
    return stk[tt];
    ```

- 队列

  - ```C++
    //在队尾插入元素，从队头弹出元素,hh表示队头，tt表示队尾
    int q[N],hh,tt=-1;
    //插入
    q[++tt] = x;
    //弹出
    hh++
    //判断是否为空
    if(hh<==tt)
        return false;
    else
        return true;
    //取出对头元素
    q[hh]
    ```

- 单调栈

  - 复杂度O(n)

  - ```c++
    int stk[N],tt;
    for(int i=0;i<nums.size();i++){
        int x = nums[i];
        while(tt && stk[tt]>=x){
            tt--;
        }
        if(tt)
            res.push_back(stk[tt]);
        else
            res.push_back(-1);
        stk[++tt] = x;
    }
    ```

- 单调队列

  -  求滑动窗口的最大值和最小值

  -  复杂度

  - ```C++
    /*滑动窗口最小值*/
    int q[N],hh,tt=-1;
    for(int i=0;i<nums.size();i++){
        if(hh<=tt && i-q[hh]+1>k) //队列是否超长
            hh++;
        while(hh<=tt && nums[q[tt]]>=nums[i]){
            tt--;
        }
        q[++tt] = i;
        if(i>=k-1)
            printf("%d",nums[q[hh]]);
    }
    ```

##### Kmp[克努特-莫里斯-普拉特操作]

- 暴力算法

  - 模拟人的判断过程

- 如何去优化

  - 使用前缀和来优化

  - ```C++
    int p[N],s[M];
    int ne[N]; //有些头文件可能使用过next数组
    //求next过程
    for(int i =2,j=0;i<=n;i++){
        while(j &&p[i] !=p[j+1])
            j = ne[j];
        if(p[i] == p[j+1])
            j++;
        ne[i] = j;
    }
    //匹配过程
    for(int i=1,j=0;i<m;++i){
        while(j && s[i]!= p[j+1] ){
            j = ne[j];
        }
        if(s[i] == p[j+1]){
            j++;
        }
        if(j == n){
            print("%d",i-n+1);
            //匹配成功
        }
    }
    ```

##### Trie字典树

- 也称为前缀树，高效的存储和查找字符串

- ```C++
  int son[N][26],cnt[N],idx;//下标为0的点，既是空节点也是根节点
  char str[N]
  void insert(char str[]){
      int p =0;
      for(int i=0;str[i];++i){
          int u = str[i] - 'a';
          if(!son[p][u]) //没有这个节点构造这个节点
              son[p][u] = ++idx;
          p = son[p][u];
      }
      cnt[p]++;
  }
  int query(char str[]){
      int p = 0;
      for(int i=0;str[i];++i){
      	int u = str[i]-'a';
          if(!son[p][u])
              return 0;
          p = son[p][u];
      }
      return cnt[p];
  }
  ```

##### 并查集

- 已掌握

##### 堆

- 如何手写一个堆,以最小堆为例

  - 插入一个数
    - 将数插入到最后一个元素
    - 然后向上更新
  - 求集合中的最小值
    - 返回堆顶元素
  - 删除最小值
    - 将头节点移动到最后一个元素
    - 删除最后一个节点
    - 对更换后的头节点，然后向下更新
  - 删除任意一个元素
    - 删除第k个点，将第k个点移动到堆顶
    - 执行删除堆顶元素
    - 需要分情况，down(k),up(k)
  - 修改任意一个元素
    - 将第k个元素赋值
    - 执行一遍up(k),down(k)

- 堆是一个完全二叉树

  - 小根堆：每一个节点的值都是小于左右节点的值
  - 使用一维数组存储树节点,根节点为x,则左节点为`2x`,右节点为`2x+1`，下标从1开始
  - down往下调整，把一个数变大就有可能需要往下调整
  - up往上调整，把一个数变小有可能需要向上调整\

- ```C++
  int h[N],size;
  //读入未排序的数组
  for(int i=0;i<=n;++i)
      scanf("%d",&h[i]);
  //先构建一个最小堆，复杂度O(n)
  for(int i=n/2;i;i--){
      down(i);
  }
  while(m--){
      h[i] = h[size]; //将最小的值与最后的一个值互换
      size--; //删除最小的元素
      down(1);
  }
  //向下移位
  void down(int u){
      int t = u;
      if(u*2<=size && h[u*2]<h[t])
          t = u*2;
      if(u*2+1 <= size && h[u*2+1]<h[t])
          t = u*2+1;
      if(u != t){
          swap(h[u],h[t]);
          down(t);
      }
  }
  //向上移位
  void up(int u){
      while(u/2 && h[u/2]>h[u]){
          swap(h[u/2],h[u]);
          u /=2;
      }
  }
  ```

##### 哈希表

##### C++STL使用技巧

